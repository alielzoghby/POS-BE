import prisma from '../utils/prismaClient.js';
import {
  CreateOrderSchema,
  UpdateOrderSchema,
  CreateOrderWithProductsSchema,
  validateSchema,
} from '../helpers/validate_schema.js';
import CustomResponse from '../helpers/customResponse.js';
import VoucherController from './voucher.js';
import { generateReference } from '../helpers/generate-reference.js';

// Helper function to calculate due amount and paid status
const calculateDueAndStatus = (totalPrice, paid) => {
  const paidAmount = paid || 0;
  const due = Math.max(0, totalPrice - paidAmount);
  const paidStatus = due > 0 ? 'IN_PROGRESS' : 'PAID';
  return { due: Number(due.toFixed(2)), paidStatus };
};

// Helpers
const computeOrderTotal = async (tx, orderIdOrProducts, voucherReference, tip) => {
  let sumProducts = 0;
  if (Array.isArray(orderIdOrProducts)) {
    sumProducts = orderIdOrProducts.reduce((sum, p) => sum + p.price * p.quantity, 0);
  } else {
    const items = await tx.productOrder.findMany({
      where: { order_id: orderIdOrProducts },
    });
    sumProducts = items.reduce((sum, p) => sum + p.price * p.quantity, 0);
  }

  // Get tax from configuration (percentage)
  const config = await tx.configuration.upsert({
    where: { id: 1 },
    update: {},
    create: { id: 1, tax: 0 },
  });

  // Apply tax to products total
  const taxAmount = sumProducts * ((config.tax || 0) / 100);
  const totalWithTax = sumProducts + taxAmount;

  // Apply voucher discount if present
  let discounted = 0;
  if (voucherReference) {
    const voucher = await tx.voucher_table.findUnique({
      where: { voucher_reference: voucherReference },
    });
    if (!voucher) {
      throw new Error('Voucher not found');
    }
    if (voucher.amount != null) {
      discounted = totalWithTax - voucher.amount < 0 ? totalWithTax : voucher.amount;
    } else if (voucher.percentage != null) {
      discounted = totalWithTax * (voucher.percentage / 100);
    }
  }

  // Add tip to final total
  const tipValue = tip || 0;
  const total = (totalWithTax - discounted < 0 ? 0 : totalWithTax - discounted) + tipValue;

  return {
    subTotal: Number(sumProducts.toFixed(2)),
    tax: config.tax,
    taxAmount: taxAmount,
    discounted: Number(discounted.toFixed(2)),
    total: Number(total.toFixed(2)),
  };
};

// Create a new order
const create = async (data, userId) => {
  const validation = validateSchema(CreateOrderSchema, data);
  if (!validation.success) {
    return [new CustomResponse(400, 'Validation failed', validation.error), null];
  }
  const validatedData = validation.data;

  // Check if client exists
  let client = null;
  if (validatedData.client_id) {
    client = await prisma.client.findUnique({
      where: { client_id: validatedData.client_id },
      include: {
        addresses: { where: { is_primary: true }, take: 1 },
        phoneNumbers: { where: { is_primary: true }, take: 1 },
      },
    });
    if (!client) {
      return [new CustomResponse(404, 'Client not found'), null];
    }
  }

  // Validate voucher if provided
  if (validatedData.voucher_reference) {
    const voucherValidation = await VoucherController.validateVoucherForOrder(
      validatedData.voucher_reference
    );
    if (!voucherValidation.valid) {
      return [new CustomResponse(400, voucherValidation.error), null];
    }
  }

  // Create order with computed total; reference auto-generated by DB
  try {
    const newOrder = await prisma.$transaction(async (tx) => {
      const totals = await computeOrderTotal(
        tx,
        [],
        validatedData.voucher_reference,
        validatedData.tip
      );
      const { due, paidStatus } = calculateDueAndStatus(totals.total, validatedData.paid);

      const orderData = {
        client_id: validatedData.client_id || null,
        voucher_reference: validatedData.voucher_reference || null,
        payment_method: validatedData.payment_method || null,
        tip: validatedData.tip || 0,
        total_price: totals.total,
        created_by: userId,
        paid: validatedData.paid || 0,
        due,
        paid_status: paidStatus,
        tax: totals.tax,
        sub_total: totals.subTotal,
        reference: generateReference(),

        phone_number: client
          ? client.phoneNumbers[0]?.phone_number || null
          : validatedData.phone_number || null,
        address: client
          ? `${client.addresses[0]?.street || ''}, ${client.addresses[0]?.city || ''}, ${
              client.addresses[0]?.country || ''
            }`.trim()
          : validatedData.address || null,
      };

      if (validatedData.voucher_reference) {
        const voucher = await tx.voucher_table.findUnique({
          where: { voucher_reference: validatedData.voucher_reference },
        });
        if (voucher && !voucher.multiple) {
          await tx.voucher_table.update({
            where: { voucher_reference: validatedData.voucher_reference },
            data: { active: false },
          });
        }
      }

      return await tx.order.create({
        data: orderData,
        include: {
          client: {
            select: {
              client_id: true,
              first_name: true,
              last_name: true,
              email: true,
              company: true,
            },
          },
          creator: {
            select: {
              user_id: true,
              first_name: true,
              last_name: true,
              email: true,
            },
          },
          productOrders: {
            include: {
              product: {
                select: {
                  product_id: true,
                  name: true,
                  reference: true,
                },
              },
            },
          },
          voucher: {
            select: {
              voucher_id: true,
              amount: true,
              percentage: true,
              voucher_reference: true,
              active: true,
              expired_at: true,
              multiple: true,
            },
          },
        },
      });
    });
    return [null, new CustomResponse(201, 'Order created successfully', newOrder)];
  } catch (e) {
    if (e.message === 'Voucher not found') {
      return [new CustomResponse(404, 'Voucher not found'), null];
    }
    throw e;
  }
};

// Create order with products
const createWithProducts = async (data, userId) => {
  const validation = validateSchema(CreateOrderWithProductsSchema, data);
  if (!validation.success) {
    return [new CustomResponse(400, 'Validation failed', validation.error), null];
  }
  const validatedData = validation.data;

  // Check if client exists (only if provided)
  let client = null;
  if (validatedData.client_id) {
    client = await prisma.client.findUnique({
      where: { client_id: validatedData.client_id },
      include: {
        addresses: { where: { is_primary: true }, take: 1 },
        phoneNumbers: { where: { is_primary: true }, take: 1 },
      },
    });
    if (!client) {
      return [new CustomResponse(404, 'Client not found'), null];
    }
  }
  // Validate voucher if provided
  if (validatedData.voucher_reference) {
    const voucherValidation = await VoucherController.validateVoucherForOrder(
      validatedData.voucher_reference
    );
    if (!voucherValidation.valid) {
      return [new CustomResponse(400, voucherValidation.error), null];
    }
  }

  // Check if all products exist and have sufficient stock
  const productIds = validatedData.products.map((p) => p.product_id);
  const existingProducts = await prisma.product.findMany({
    where: { product_id: { in: productIds } },
  });

  if (existingProducts.length !== productIds.length) {
    return [new CustomResponse(404, 'One or more products not found'), null];
  }

  // Check stock availability
  const stockErrors = [];
  for (const orderProduct of validatedData.products) {
    const product = existingProducts.find((p) => p.product_id === orderProduct.product_id);
    if (product.quantity < orderProduct.quantity) {
      stockErrors.push({
        product_id: product.product_id,
        product_name: product.name,
        available: product.quantity,
        requested: orderProduct.quantity,
      });
    }
  }

  if (stockErrors.length > 0) {
    return [new CustomResponse(400, 'Insufficient stock for some products', { stockErrors }), null];
  }

  // Create order with products in a transaction
  const result = await prisma.$transaction(async (tx) => {
    // Create the order
    const newOrder = await tx.order.create({
      data: {
        client_id: validatedData.client_id,
        voucher_reference: validatedData.voucher_reference || null,
        payment_method: validatedData.payment_method || null,
        tip: validatedData.tip || 0,
        total_price: 0,
        created_by: userId,
        paid: validatedData.paid || 0,
        due: 0,
        paid_status: 'IN_PROGRESS',
        tax: 0,
        sub_total: 0,
        reference: generateReference(),
        phone_number: client
          ? client.phoneNumbers[0]?.phone_number || null
          : validatedData.phone_number || null,
        address: client
          ? `${client.addresses[0]?.street || ''}, ${client.addresses[0]?.city || ''}, ${
              client.addresses[0]?.state || ''
            }, ${client.addresses[0]?.country || ''} - ${
              client.addresses[0]?.postal_code || ''
            }`.trim()
          : validatedData.address || null,
      },
    });

    // Create product orders and reduce quantities
    const productOrders = await Promise.all(
      validatedData.products.map(async (product) => {
        // Create the product order
        const productOrder = await tx.productOrder.create({
          data: {
            order_id: newOrder.order_id,
            product_id: product.product_id,
            quantity: product.quantity,
            price: product.price,
          },
        });

        // Reduce product quantity
        await tx.product.update({
          where: { product_id: product.product_id },
          data: {
            quantity: {
              decrement: product.quantity,
            },
          },
        });

        return productOrder;
      })
    );

    // Compute total and update order
    const totals = await computeOrderTotal(
      tx,
      newOrder.order_id,
      validatedData.voucher_reference,
      validatedData.tip
    );
    const { due, paidStatus } = calculateDueAndStatus(totals.total, validatedData.paid);

    // If voucher is single-use, mark it as inactive after first use
    if (validatedData.voucher_reference) {
      const voucher = await tx.voucher_table.findUnique({
        where: { voucher_reference: validatedData.voucher_reference },
      });
      if (voucher && !voucher.multiple) {
        await tx.voucher_table.update({
          where: { voucher_reference: validatedData.voucher_reference },
          data: { active: false },
        });
      }
    }

    await tx.order.update({
      where: { order_id: newOrder.order_id },
      data: {
        total_price: totals.total,
        due,
        paid_status: paidStatus,
        tax: totals.tax,
        taxAmount: totals.taxAmount,
        sub_total: totals.subTotal,
        discounted: totals.discounted,
      },
    });

    // Return the complete order with relations
    return await tx.order.findUnique({
      where: { order_id: newOrder.order_id },
      include: {
        client: {
          select: {
            client_id: true,
            first_name: true,
            last_name: true,
            email: true,
            company: true,
          },
        },
        creator: {
          select: {
            user_id: true,
            first_name: true,
            last_name: true,
            email: true,
          },
        },
        productOrders: {
          include: {
            product: {
              select: {
                product_id: true,
                name: true,
                reference: true,
              },
            },
          },
        },
        voucher: {
          select: {
            voucher_id: true,
            amount: true,
            percentage: true,
            voucher_reference: true,
            active: true,
            expired_at: true,
            multiple: true,
          },
        },
      },
    });
  });

  return [null, new CustomResponse(201, 'Order with products created successfully', result)];
};

// Get orders analysis

export const getOrdersAnalysis = async (where) => {
  try {
    const allFilteredOrders = await prisma.order.findMany({ where });

    const analysis = allFilteredOrders.reduce(
      (acc, order) => {
        acc.totalSubTotal += order.sub_total || 0;
        acc.totalDue += order.due || 0;
        acc.totalTip += order.tip || 0;
        acc.totalTaxAmount += order.taxAmount || 0;
        acc.totalTotalPrice += order.total_price || 0;
        acc.totalDiscounted += order.discounted || 0;
        return acc;
      },
      {
        totalSubTotal: 0,
        totalDue: 0,
        totalTip: 0,
        totalTaxAmount: 0,
        totalTotalPrice: 0,
        totalDiscounted: 0,
      }
    );

    const totalAnalysis = {
      totalSubTotal: Number(analysis.totalSubTotal.toFixed(2)),
      totalDue: Number(analysis.totalDue.toFixed(2)),
      totalTip: Number(analysis.totalTip.toFixed(2)),
      totalTaxAmount: Number(analysis.totalTaxAmount.toFixed(2)),
      totalTotalPrice: Number(analysis.totalTotalPrice.toFixed(2)),
      totalDiscounted: Number(analysis.totalDiscounted.toFixed(2)),
    };

    return [null, totalAnalysis];
  } catch (error) {
    console.error('Error calculating analysis:', error);
    return [error, null];
  }
};

// Get all orders with optional filtering
export const getAll = async (query) => {
  try {
    const {
      page = 1,
      limit = 10,
      search,
      reference,
      client_id,
      minPrice,
      maxPrice,
      startFrom,
      endDate,
      sortBy = 'order_id',
      sortOrder = 'asc',
    } = query;

    const skip = (parseInt(page) - 1) * parseInt(limit);
    const take = parseInt(limit);

    // Build where clause
    const where = {};

    if (search) {
      where.OR = [
        { reference: { contains: search } },
        {
          client: {
            OR: [
              { first_name: { contains: search } },
              { last_name: { contains: search } },
              { email: { contains: search } },
              { company: { contains: search } },
            ],
          },
        },
      ];
    }

    if (reference) where.reference = { contains: reference };

    if (client_id) {
      if (Array.isArray(client_id)) {
        where.client_id = { in: client_id.map((id) => parseInt(id)) };
      } else {
        where.client_id = parseInt(client_id);
      }
    }

    if (minPrice !== undefined || maxPrice !== undefined) {
      where.total_price = {};
      if (minPrice !== undefined) where.total_price.gte = minPrice;
      if (maxPrice !== undefined) where.total_price.lte = maxPrice;
    }

    if (startFrom || endDate) {
      where.created_at = {};
      if (startFrom) where.created_at.gte = new Date(startFrom);
      if (endDate) where.created_at.lte = new Date(endDate);
    }

    const orderBy = {};
    orderBy[sortBy] = sortOrder;

    const [orders, totalCount] = await Promise.all([
      prisma.order.findMany({
        where,
        skip,
        take,
        orderBy,
        include: {
          client: {
            select: {
              client_id: true,
              first_name: true,
              last_name: true,
              email: true,
              company: true,
            },
          },
          creator: { select: { user_id: true, first_name: true, last_name: true, email: true } },
          productOrders: {
            include: { product: { select: { product_id: true, name: true, reference: true } } },
          },
          voucher: {
            select: {
              voucher_id: true,
              amount: true,
              percentage: true,
              voucher_reference: true,
              active: true,
              expired_at: true,
              multiple: true,
            },
          },
        },
      }),
      prisma.order.count({ where }),
    ]);

    const totalPages = Math.ceil(totalCount / take);

    const [analysisErr, analysis] = await getOrdersAnalysis(where);
    if (analysisErr) {
      console.error('Error calculating analysis:', analysisErr);
    }

    const result = {
      orders,
      pagination: {
        currentPage: parseInt(page),
        totalPages,
        totalDocuments: totalCount,
        limit: take,
      },
      analysis: analysis || {
        totalSubTotal: 0,
        totalDue: 0,
        totalTip: 0,
        totalTax: 0,
        totalTotalPrice: 0,
      },
    };

    return [null, new CustomResponse(200, 'Orders fetched successfully', result)];
  } catch (error) {
    console.error('Error fetching orders:', error);
    return [new CustomResponse(500, 'Failed to fetch orders'), null];
  }
};

// Get order by ID
const getById = async (id) => {
  try {
    const orderId = parseInt(id);
    if (isNaN(orderId)) {
      return [new CustomResponse(400, 'Invalid order ID'), null];
    }

    const order = await prisma.order.findUnique({
      where: { order_id: orderId },
      include: {
        client: {
          select: {
            client_id: true,
            first_name: true,
            last_name: true,
            email: true,
            company: true,
          },
        },
        creator: {
          select: {
            user_id: true,
            first_name: true,
            last_name: true,
            email: true,
          },
        },
        productOrders: {
          include: {
            product: {
              select: {
                product_id: true,
                name: true,
                reference: true,
                base_price: true,
                final_price: true,
              },
            },
          },
        },
        voucher: {
          select: {
            voucher_id: true,
            amount: true,
            percentage: true,
            voucher_reference: true,
            active: true,
            expired_at: true,
            multiple: true,
          },
        },
      },
    });

    if (!order) {
      return [new CustomResponse(404, 'Order not found'), null];
    }

    return [null, new CustomResponse(200, 'Order fetched successfully', order)];
  } catch (error) {
    console.error('Error fetching order:', error);
    return [new CustomResponse(500, 'Failed to fetch order'), null];
  }
};

// Update order
const update = async (id, data) => {
  try {
    const orderId = parseInt(id);
    if (isNaN(orderId)) {
      return [new CustomResponse(400, 'Invalid order ID'), null];
    }

    // ✅ Validate request
    const validation = validateSchema(UpdateOrderSchema, data);
    if (!validation.success) {
      return [new CustomResponse(400, 'Validation failed', validation.error), null];
    }
    const validatedData = validation.data;

    // ✅ Check if order exists
    const existingOrder = await prisma.order.findUnique({
      where: { order_id: orderId },
      include: { productOrders: true },
    });
    if (!existingOrder) {
      return [new CustomResponse(404, 'Order not found'), null];
    }

    // ✅ Run transaction
    const updatedOrder = await prisma.$transaction(async (tx) => {
      if (validatedData.products && validatedData.products.length > 0) {
        // Handle added/updated products
        for (const p of validatedData.products) {
          const product = await tx.product.findUnique({
            where: { product_id: p.product_id },
          });
          if (!product) {
            throw new Error(`Product ${p.product_id} not found`);
          }

          // Find existing productOrder
          const existingPO = await tx.productOrder.findUnique({
            where: {
              product_id_order_id: {
                product_id: p.product_id,
                order_id: orderId,
              },
            },
          });

          const newQty = p.quantity;
          const oldQty = existingPO ? existingPO.quantity : 0;
          const diff = newQty - oldQty;

          if (diff > 0) {
            // Increase → check stock
            if (diff > product.quantity) {
              throw new Error(
                `Not enough stock for product ${product.name} (available: ${product.quantity})`
              );
            }
            await tx.product.update({
              where: { product_id: p.product_id },
              data: { quantity: { decrement: diff } },
            });
          } else if (diff < 0) {
            // Decrease → return stock
            await tx.product.update({
              where: { product_id: p.product_id },
              data: { quantity: { increment: Math.abs(diff) } },
            });
          }

          // Upsert productOrder
          await tx.productOrder.upsert({
            where: {
              product_id_order_id: {
                product_id: p.product_id,
                order_id: orderId,
              },
            },
            update: {
              quantity: newQty,
              price: p.price ?? product.final_price,
            },
            create: {
              product_id: p.product_id,
              order_id: orderId,
              quantity: newQty,
              price: p.price ?? product.final_price,
            },
          });
        }

        // ✅ Handle removed products
        const incomingIds = validatedData.products.map((p) => p.product_id);
        const removedProducts = existingOrder.productOrders.filter(
          (po) => !incomingIds.includes(po.product_id)
        );

        for (const removed of removedProducts) {
          // Return stock
          await tx.product.update({
            where: { product_id: removed.product_id },
            data: { quantity: { increment: removed.quantity } },
          });

          // Delete relation
          await tx.productOrder.delete({
            where: {
              product_id_order_id: {
                product_id: removed.product_id,
                order_id: orderId,
              },
            },
          });
        }
      }

      // ✅ Recalculate totals
      const totals = await computeOrderTotal(
        tx,
        orderId,
        validatedData.voucher_reference ?? existingOrder.voucher_reference,
        validatedData.tip ?? existingOrder.tip
      );

      const finalPaid = validatedData.paid ?? existingOrder.paid;
      const { due, paidStatus } = calculateDueAndStatus(totals.total, finalPaid);

      const { products, ...rest } = validatedData;

      return await tx.order.update({
        where: { order_id: orderId },
        data: {
          ...rest,
          total_price: totals.total,
          due,
          paid_status: paidStatus,
          tax: totals.tax,
          taxAmount: totals.taxAmount,
          sub_total: totals.subTotal,
          discounted: totals.discounted,
        },
        include: {
          client: true,
          creator: true,
          productOrders: { include: { product: true } },
          voucher: true,
        },
      });
    });

    return [null, new CustomResponse(200, 'Order updated successfully', updatedOrder)];
  } catch (error) {
    console.error('Error updating order:', error);
    return [new CustomResponse(500, 'Failed to update order'), null];
  }
};

// Delete order
const remove = async (id) => {
  try {
    const orderId = parseInt(id);
    if (isNaN(orderId)) {
      return [new CustomResponse(400, 'Invalid order ID'), null];
    }

    // Check if order exists
    const existingOrder = await prisma.order.findUnique({
      where: { order_id: orderId },
      include: {
        productOrders: true,
      },
    });
    if (!existingOrder) {
      return [new CustomResponse(404, 'Order not found'), null];
    }

    // Delete order and restore product quantities in a transaction
    await prisma.$transaction(async (tx) => {
      // Restore product quantities
      for (const productOrder of existingOrder.productOrders) {
        await tx.product.update({
          where: { product_id: productOrder.product_id },
          data: {
            quantity: {
              increment: productOrder.quantity,
            },
          },
        });
      }

      // Delete related product orders first
      await tx.productOrder.deleteMany({
        where: { order_id: orderId },
      });

      // Then delete the order
      await tx.order.delete({
        where: { order_id: orderId },
      });
    });

    return [null, new CustomResponse(200, 'Order deleted successfully')];
  } catch (error) {
    console.error('Error deleting order:', error);
    return [new CustomResponse(500, 'Failed to delete order'), null];
  }
};

export default {
  create,
  createWithProducts,
  getAll,
  getById,
  update,
  remove,
};
